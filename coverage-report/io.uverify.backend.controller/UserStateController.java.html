<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserStateController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Uverify Backend</a> &gt; <a href="index.source.html" class="el_package">io.uverify.backend.controller</a> &gt; <span class="el_source">UserStateController.java</span></div><h1>UserStateController.java</h1><pre class="source lang-java linenums">/*
 * UVerify Backend
 * Copyright (C) 2025 Fabian Bormann
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package io.uverify.backend.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.uverify.backend.dto.ExecuteUserActionRequest;
import io.uverify.backend.dto.ExecuteUserActionResponse;
import io.uverify.backend.dto.UserActionRequest;
import io.uverify.backend.dto.UserActionResponse;
import io.uverify.backend.enums.UserAction;
import io.uverify.backend.service.UserStateService;
import org.jetbrains.annotations.NotNull;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@SuppressWarnings(&quot;unused&quot;)
@RequestMapping(&quot;/api/v1/user&quot;)
@Tag(name = &quot;User State Management&quot;, description = &quot;Endpoints for managing user states and performing user-related actions.&quot;)
<span class="fc" id="L46">public class UserStateController {</span>

    @Autowired
    private UserStateService userStateService;

    @PostMapping(&quot;/request/action&quot;)
    @Operation(
            summary = &quot;Create a user state action request&quot;,
            description = &quot;&quot;&quot;
                    Creates a request object for a specific user state action. The backend signs the request message, and the user must also sign the message to execute the action in the next step. Supported actions include:
                    - **USER_INFO**: Retrieve user information based on the provided address.
                    - **INVALIDATE_STATE**: Create a request to invalidate a specific user state. This will prepare an unsigned transaction to burn the state token, collect the UTXO locked in the contract, and send it (including ADA) to the user's wallet.
                    - **OPT_OUT**: Create a request to invalidate all states and claim back all locked UTXOs.&quot;&quot;&quot;
    )
    @ApiResponses(value = {
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Action request successfully created&quot;,
                    content = @Content(mediaType = &quot;application/json&quot;, schema = @Schema(implementation = UserActionResponse.class))),
            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Invalid request or unknown action type&quot;,
                    content = @Content(mediaType = &quot;application/json&quot;, schema = @Schema(implementation = UserActionResponse.class))),
            @ApiResponse(responseCode = &quot;500&quot;, description = &quot;Internal server error&quot;)
    })
    public ResponseEntity&lt;UserActionResponse&gt; requestUserState(@RequestBody @NotNull UserActionRequest request) {
<span class="fc" id="L68">        UserActionResponse response = new UserActionResponse();</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">        if (request.getAction().equals(UserAction.USER_INFO)) {</span>
<span class="fc" id="L70">            return ResponseEntity.ok(userStateService.requestUserInfo(request.getAddress()));</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        } else if (request.getAction().equals(UserAction.INVALIDATE_STATE)) {</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">            if (request.getStateId() == null) {</span>
<span class="nc" id="L73">                response.setError(&quot;State ID is required for invalidation.&quot;);</span>
<span class="nc" id="L74">                response.setStatus(HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L75">                return ResponseEntity.badRequest().body(response);</span>
            }
<span class="nc" id="L77">            return ResponseEntity.ok(userStateService.requestInvalidateState(request.getAddress(), request.getStateId()));</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        } else if (request.getAction().equals(UserAction.OPT_OUT)) {</span>
<span class="nc" id="L79">            return ResponseEntity.ok(userStateService.requestOptOut(request.getAddress()));</span>
        }

<span class="nc" id="L82">        response.setError(&quot;Unknown action type or invalid request.&quot;);</span>
<span class="nc" id="L83">        response.setStatus(HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L84">        return ResponseEntity.badRequest().body(response);</span>
    }

    @PostMapping(&quot;/state/action&quot;)
    @Operation(
            summary = &quot;Execute a user state action&quot;,
            description = &quot;&quot;&quot;
                    Executes a user state action based on the signed request created in the previous step. The backend prepares an unsigned transaction for the action, which must be signed and submitted by the user. Supported actions include:
                    - **USER_INFO**: Execute a request to retrieve user information.
                    - **INVALIDATE_STATE**: Execute a request to invalidate a specific user state. This will return an unsigned transaction to burn the state token, collect the UTXO locked in the contract, and send it (including ADA) to the user's wallet.
                    - **OPT_OUT**: Execute a request to invalidate all states and claim back all locked UTXOs.

                    The unsigned transaction returned by this endpoint must be signed by the user using their wallet or submitted to the `/api/v1/transaction/submit` endpoint.&quot;&quot;&quot;
    )
    @ApiResponses(value = {
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Action successfully executed&quot;,
                    content = @Content(mediaType = &quot;application/json&quot;, schema = @Schema(implementation = ExecuteUserActionResponse.class))),
            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Invalid request or unknown action type&quot;,
                    content = @Content(mediaType = &quot;application/json&quot;)),
            @ApiResponse(responseCode = &quot;500&quot;, description = &quot;Internal server error&quot;)
    })
    public ResponseEntity&lt;?&gt; executeStateAction(@RequestBody @NotNull ExecuteUserActionRequest request) {
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (request.getAction().equals(UserAction.USER_INFO)) {</span>
<span class="fc" id="L107">            return ResponseEntity.ok(userStateService.executeUserInfoRequest(request));</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        } else if (request.getAction().equals(UserAction.INVALIDATE_STATE)) {</span>
<span class="nc" id="L109">            return ResponseEntity.ok(userStateService.executeStateInvalidationRequest(request));</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        } else if (request.getAction().equals(UserAction.OPT_OUT)) {</span>
<span class="nc" id="L111">            return ResponseEntity.ok(userStateService.executeUserOptOut(request));</span>
        }
<span class="nc" id="L113">        return ResponseEntity.badRequest().body(&quot;Unknown action type or invalid request.&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>