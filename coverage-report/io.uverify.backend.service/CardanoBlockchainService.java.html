<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CardanoBlockchainService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Uverify Backend</a> &gt; <a href="index.source.html" class="el_package">io.uverify.backend.service</a> &gt; <span class="el_source">CardanoBlockchainService.java</span></div><h1>CardanoBlockchainService.java</h1><pre class="source lang-java linenums">/*
 * UVerify Backend
 * Copyright (C) 2025 Fabian Bormann
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package io.uverify.backend.service;

import com.bloxbean.cardano.client.account.Account;
import com.bloxbean.cardano.client.address.Address;
import com.bloxbean.cardano.client.address.AddressProvider;
import com.bloxbean.cardano.client.address.Credential;
import com.bloxbean.cardano.client.api.UtxoSupplier;
import com.bloxbean.cardano.client.api.exception.ApiException;
import com.bloxbean.cardano.client.api.model.Amount;
import com.bloxbean.cardano.client.api.model.Result;
import com.bloxbean.cardano.client.api.model.Utxo;
import com.bloxbean.cardano.client.backend.api.BackendService;
import com.bloxbean.cardano.client.backend.api.DefaultUtxoSupplier;
import com.bloxbean.cardano.client.backend.blockfrost.service.BFBackendService;
import com.bloxbean.cardano.client.backend.koios.Constants;
import com.bloxbean.cardano.client.backend.koios.KoiosBackendService;
import com.bloxbean.cardano.client.backend.model.TxContentUtxo;
import com.bloxbean.cardano.client.backend.model.TxContentUtxoOutputs;
import com.bloxbean.cardano.client.exception.CborSerializationException;
import com.bloxbean.cardano.client.plutus.blueprint.PlutusBlueprintUtil;
import com.bloxbean.cardano.client.plutus.blueprint.model.PlutusVersion;
import com.bloxbean.cardano.client.plutus.spec.PlutusData;
import com.bloxbean.cardano.client.plutus.spec.PlutusScript;
import com.bloxbean.cardano.client.quicktx.QuickTxBuilder;
import com.bloxbean.cardano.client.quicktx.ScriptTx;
import com.bloxbean.cardano.client.transaction.TransactionSigner;
import com.bloxbean.cardano.client.transaction.spec.Asset;
import com.bloxbean.cardano.client.transaction.spec.Transaction;
import com.bloxbean.cardano.client.util.HexUtil;
import com.bloxbean.cardano.yaci.store.common.domain.AddressUtxo;
import io.uverify.backend.entity.BootstrapDatumEntity;
import io.uverify.backend.entity.FeeReceiverEntity;
import io.uverify.backend.entity.StateDatumEntity;
import io.uverify.backend.entity.UVerifyCertificateEntity;
import io.uverify.backend.enums.CardanoNetwork;
import io.uverify.backend.model.BootstrapDatum;
import io.uverify.backend.model.StateDatum;
import io.uverify.backend.model.UVerifyCertificate;
import io.uverify.backend.util.CardanoUtils;
import io.uverify.backend.util.ValidatorUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.DigestUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;

import static io.uverify.backend.util.CardanoUtils.fromCardanoNetwork;
import static io.uverify.backend.util.ValidatorUtils.*;

@Service
<span class="fc" id="L78">@Slf4j</span>
public class CardanoBlockchainService {
    @Autowired
    private final BootstrapDatumService bootstrapDatumService;
    @Autowired
    private final StateDatumService stateDatumService;
    @Autowired
    private final UVerifyCertificateService uVerifyCertificateService;
    private final CardanoNetwork network;
    private final Address serviceUserAddress;
    private BackendService backendService;

    @Autowired
    public CardanoBlockchainService(@Value(&quot;${cardano.service.user.address}&quot;) String serviceUserAddress,
                                    @Value(&quot;${cardano.backend.service.type}&quot;) String cardanoBackendServiceType,
                                    @Value(&quot;${cardano.backend.blockfrost.baseUrl}&quot;) String blockfrostBaseUrl,
                                    @Value(&quot;${cardano.backend.blockfrost.projectId}&quot;) String blockfrostProjectId,
                                    @Value(&quot;${cardano.network}&quot;) String network,
                                    UVerifyCertificateService uVerifyCertificateService,
                                    BootstrapDatumService bootstrapDatumService, StateDatumService stateDatumService
<span class="fc" id="L98">    ) {</span>
<span class="fc" id="L99">        this.bootstrapDatumService = bootstrapDatumService;</span>
<span class="fc" id="L100">        this.stateDatumService = stateDatumService;</span>
<span class="fc" id="L101">        this.uVerifyCertificateService = uVerifyCertificateService;</span>
<span class="fc" id="L102">        this.network = CardanoNetwork.valueOf(network);</span>
<span class="fc" id="L103">        this.serviceUserAddress = new Address(serviceUserAddress);</span>

<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (cardanoBackendServiceType.equals(&quot;blockfrost&quot;)) {</span>
<span class="nc bnc" id="L106" title="All 4 branches missed.">            if (blockfrostProjectId == null || blockfrostProjectId.isEmpty()) {</span>
<span class="nc" id="L107">                throw new IllegalArgumentException(&quot;Blockfrost projectId is required when using Blockfrost backend service&quot;);</span>
            }

<span class="nc" id="L110">            this.backendService = new BFBackendService(</span>
                    blockfrostBaseUrl,
                    blockfrostProjectId);
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        } else if (cardanoBackendServiceType.equals(&quot;koios&quot;)) {</span>
<span class="nc" id="L114">            this.backendService = new KoiosBackendService(Constants.KOIOS_PREPROD_URL);</span>
        }
<span class="fc" id="L116">    }</span>

    public Result&lt;String&gt; submitTransaction(Transaction transaction, Account signer) throws CborSerializationException, ApiException {
<span class="fc" id="L119">        Transaction signedTransaction = TransactionSigner.INSTANCE.sign(transaction, signer.hdKeyPair());</span>
<span class="fc" id="L120">        return submitTransaction(signedTransaction);</span>
    }

    public Result&lt;String&gt; submitTransaction(Transaction transaction) throws CborSerializationException, ApiException {
<span class="fc" id="L124">        return backendService.getTransactionService().submitTransaction(transaction.serialize());</span>
    }

    public void setBackendService(BackendService backendService) {
<span class="fc" id="L128">        this.backendService = backendService;</span>
<span class="fc" id="L129">    }</span>

    public Transaction updateStateDatum(String address, List&lt;UVerifyCertificate&gt; uVerifyCertificates) throws ApiException {
<span class="fc" id="L132">        return updateStateDatum(address, uVerifyCertificates, &quot;&quot;);</span>
    }

    public Transaction updateStateDatum(String address, List&lt;UVerifyCertificate&gt; uVerifyCertificates, String bootstrapTokenName) throws ApiException {
<span class="fc" id="L136">        Optional&lt;StateDatumEntity&gt; stateDatumEntity = Optional.empty();</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (bootstrapTokenName.isEmpty()) {</span>
<span class="fc" id="L138">            List&lt;StateDatumEntity&gt; stateDatumEntities = stateDatumService.findByOwner(address);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            if (stateDatumEntities.size() == 1) {</span>
<span class="fc" id="L140">                stateDatumEntity = Optional.of(stateDatumEntities.get(0));</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            } else if (stateDatumEntities.size() &gt; 1) {</span>
<span class="nc" id="L142">                stateDatumEntity = Optional.of(stateDatumService.selectCheapestStateDatum(stateDatumEntities));</span>
            }
<span class="fc" id="L144">        } else {</span>
<span class="nc" id="L145">            stateDatumEntity = stateDatumService.findByUserAndBootstrapToken(address, bootstrapTokenName);</span>
        }

<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (stateDatumEntity.isEmpty()) {</span>
<span class="nc" id="L149">            throw new IllegalArgumentException(&quot;No applicable state datum found for user account&quot;);</span>
        }

<span class="fc" id="L152">        StateDatumEntity stateDatum = stateDatumEntity.get();</span>
<span class="fc" id="L153">        return updateStateDatum(address, stateDatum, uVerifyCertificates);</span>
    }

    public Transaction updateStateDatum(String address, StateDatumEntity stateDatum, List&lt;UVerifyCertificate&gt; uVerifyCertificates) throws ApiException {
<span class="fc" id="L157">        Address userAddress = new Address(address);</span>
<span class="fc" id="L158">        Optional&lt;byte[]&gt; optionalUserPaymentCredential = userAddress.getPaymentCredentialHash();</span>

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (optionalUserPaymentCredential.isEmpty()) {</span>
<span class="nc" id="L161">            throw new IllegalArgumentException(&quot;Invalid Cardano payment address&quot;);</span>
        }

<span class="fc" id="L164">        byte[] userAccountCredential = optionalUserPaymentCredential.get();</span>

<span class="fc" id="L166">        String unit = getMintStateTokenHash(network) + Hex.encodeHexString(userAccountCredential);</span>

<span class="fc" id="L168">        Optional&lt;Utxo&gt; optionalUtxo = ValidatorUtils.getUtxoByTransactionAndUnit(stateDatum.getTransactionId(), unit, backendService);</span>

<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (optionalUtxo.isEmpty()) {</span>
<span class="nc" id="L171">            throw new IllegalArgumentException(&quot;State token not found in transaction outputs&quot;);</span>
        }

<span class="fc" id="L174">        Utxo utxo = optionalUtxo.get();</span>

<span class="fc" id="L176">        PlutusScript updateTestStateTokenScript = PlutusBlueprintUtil.getPlutusScriptFromCompiledCode(getUpdateStateTokenCode(network), PlutusVersion.v3);</span>
<span class="fc" id="L177">        String updateTestStateScriptAddress = AddressProvider.getEntAddress(updateTestStateTokenScript, fromCardanoNetwork(network)).toBech32();</span>

<span class="fc" id="L179">        StateDatum nextStateDatum = StateDatum.fromPreviousStateDatum(utxo.getInlineDatum());</span>
<span class="fc" id="L180">        nextStateDatum.setUVerifyCertificates(uVerifyCertificates);</span>
<span class="fc" id="L181">        ScriptTx updateStateTokenTx = new ScriptTx()</span>
<span class="fc" id="L182">                .collectFrom(utxo, PlutusData.unit())</span>
<span class="fc" id="L183">                .payToContract(updateTestStateScriptAddress, utxo.getAmount(), nextStateDatum.toPlutusData(network))</span>
<span class="fc" id="L184">                .attachSpendingValidator(updateTestStateTokenScript);</span>

<span class="fc" id="L186">        BootstrapDatumEntity bootstrapDatum = stateDatum.getBootstrapDatum();</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (stateDatum.getCountdown() % bootstrapDatum.getFeeInterval() == 0) {</span>
<span class="fc" id="L188">            long fee = bootstrapDatum.getFee() / bootstrapDatum.getFeeReceivers().size();</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            for (FeeReceiverEntity feeReceiver : bootstrapDatum.getFeeReceivers()) {</span>
<span class="fc" id="L190">                Credential credential = Credential.fromKey(feeReceiver.getCredential());</span>
<span class="fc" id="L191">                Address feeReceiverAddress = AddressProvider.getEntAddress(credential, fromCardanoNetwork(network));</span>
<span class="fc" id="L192">                updateStateTokenTx.payToAddress(feeReceiverAddress.getAddress(), Amount.lovelace(BigInteger.valueOf(fee)));</span>
<span class="fc" id="L193">            }</span>
        }

<span class="fc" id="L196">        long currentSlot = CardanoUtils.getLatestSlot(backendService);</span>
<span class="fc" id="L197">        long validFrom = currentSlot - 10;</span>
<span class="fc" id="L198">        long transactionTtl = currentSlot + 600; // 10 minutes</span>

<span class="fc" id="L200">        QuickTxBuilder quickTxBuilder = new QuickTxBuilder(backendService);</span>
<span class="fc" id="L201">        return quickTxBuilder.compose(updateStateTokenTx)</span>
<span class="fc" id="L202">                .validFrom(validFrom)</span>
<span class="fc" id="L203">                .validTo(transactionTtl)</span>
<span class="fc" id="L204">                .collateralPayer(address)</span>
<span class="fc" id="L205">                .feePayer(address)</span>
<span class="fc" id="L206">                .withRequiredSigners(userAddress)</span>
<span class="fc" id="L207">                .build();</span>
    }

    public Transaction persistUVerifyCertificates(String address, List&lt;UVerifyCertificate&gt; uVerifyCertificate) throws ApiException {
<span class="fc" id="L211">        List&lt;StateDatumEntity&gt; stateDatumEntities = stateDatumService.findByOwner(address);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (stateDatumEntities.isEmpty()) {</span>
<span class="fc" id="L213">            log.debug(&quot;No state datum found for address &quot; + address + &quot;. Start forking a new state datum.&quot;);</span>
<span class="fc" id="L214">            return forkStateDatum(address, uVerifyCertificate);</span>
        } else {
<span class="fc" id="L216">            StateDatumEntity stateDatumEntity = stateDatumService.selectCheapestStateDatum(stateDatumEntities);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">            boolean needsToPayFee = stateDatumEntity.getCountdown() % stateDatumEntity.getBootstrapDatum().getFeeInterval() == 0;</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            if (needsToPayFee) {</span>
<span class="nc" id="L219">                log.debug(&quot;Fee required for updating state datum. Checking for better conditions.&quot;);</span>
<span class="nc" id="L220">                Address userAddress = new Address(address);</span>
<span class="nc" id="L221">                Optional&lt;byte[]&gt; optionalUserAccountCredential = userAddress.getPaymentCredentialHash();</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">                if (optionalUserAccountCredential.isEmpty()) {</span>
<span class="nc" id="L224">                    throw new IllegalArgumentException(&quot;Invalid Cardano payment address&quot;);</span>
                }
<span class="nc" id="L226">                Optional&lt;BootstrapDatum&gt; bootstrapDatum = bootstrapDatumService.selectCheapestBootstrapDatum(optionalUserAccountCredential.get());</span>

<span class="nc bnc" id="L228" title="All 2 branches missed.">                if (bootstrapDatum.isEmpty()) {</span>
<span class="nc" id="L229">                    return updateStateDatum(address, stateDatumEntity, uVerifyCertificate);</span>
                }

<span class="nc" id="L232">                double bootstrapFeeEveryHundredTransactions = (100.0 / bootstrapDatum.get().getFeeInterval()) * bootstrapDatum.get().getFee();</span>
<span class="nc" id="L233">                double stateFeeEveryHundredTransactions = (100.0 / stateDatumEntity.getBootstrapDatum().getFeeInterval()) * stateDatumEntity.getBootstrapDatum().getFee();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (bootstrapFeeEveryHundredTransactions &lt; stateFeeEveryHundredTransactions) {</span>
<span class="nc" id="L235">                    log.debug(&quot;Forking state datum with better conditions.&quot;);</span>
<span class="nc" id="L236">                    return forkStateDatum(address, uVerifyCertificate, bootstrapDatum.get().getTokenName());</span>
                } else {
<span class="nc" id="L238">                    log.debug(&quot;Updating state datum with current conditions.&quot;);</span>
<span class="nc" id="L239">                    return updateStateDatum(address, stateDatumEntity, uVerifyCertificate);</span>
                }
            } else {
<span class="fc" id="L242">                log.debug(&quot;No fee required for updating state datum&quot;);</span>
<span class="fc" id="L243">                return updateStateDatum(address, stateDatumEntity, uVerifyCertificate);</span>
            }
        }
    }

    public Transaction forkStateDatum(String address, List&lt;UVerifyCertificate&gt; uVerifyCertificates) throws ApiException {
<span class="fc" id="L249">        Address userAddress = new Address(address);</span>
<span class="fc" id="L250">        Optional&lt;byte[]&gt; optionalUserAccountCredential = userAddress.getPaymentCredentialHash();</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (optionalUserAccountCredential.isEmpty()) {</span>
<span class="nc" id="L253">            throw new IllegalArgumentException(&quot;Invalid Cardano payment address&quot;);</span>
        }

<span class="fc" id="L256">        Optional&lt;BootstrapDatum&gt; optionalBootstrapDatum = bootstrapDatumService.selectCheapestBootstrapDatum(optionalUserAccountCredential.get());</span>

<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (optionalBootstrapDatum.isEmpty()) {</span>
<span class="nc" id="L259">            throw new IllegalArgumentException(&quot;No applicable bootstrap datum found for user account&quot;);</span>
        }

<span class="fc" id="L262">        return forkStateDatum(address, uVerifyCertificates, optionalBootstrapDatum.get().getTokenName());</span>
    }

    public Transaction forkStateDatum(String address, List&lt;UVerifyCertificate&gt; uVerifyCertificates, String bootstrapTokenName) throws ApiException {
<span class="fc" id="L266">        Optional&lt;BootstrapDatumEntity&gt; optionalBootstrapDatumEntity = bootstrapDatumService.getBootstrapDatum(bootstrapTokenName);</span>

<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        if (optionalBootstrapDatumEntity.isEmpty()) {</span>
<span class="nc" id="L269">            throw new IllegalArgumentException(&quot;Bootstrap datum with name &quot; + bootstrapTokenName + &quot; not found&quot;);</span>
        }

<span class="fc" id="L272">        BootstrapDatumEntity bootstrapDatumEntity = optionalBootstrapDatumEntity.get();</span>

<span class="fc" id="L274">        Address userAddress = new Address(address);</span>
<span class="fc" id="L275">        Optional&lt;byte[]&gt; optionalUserAccountCredential = userAddress.getPaymentCredentialHash();</span>

<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        if (optionalUserAccountCredential.isEmpty()) {</span>
<span class="nc" id="L278">            throw new IllegalArgumentException(&quot;Invalid Cardano payment address&quot;);</span>
        }

<span class="fc" id="L281">        byte[] userAccountCredential = optionalUserAccountCredential.get();</span>
<span class="fc" id="L282">        Result&lt;TxContentUtxo&gt; transactionUtxosResult = backendService.getTransactionService().getTransactionUtxos(bootstrapDatumEntity.getTransactionId());</span>

<span class="fc" id="L284">        String unit = getMintOrBurnAuthTokenHash(network) + HexUtil.encodeHexString(bootstrapTokenName.getBytes());</span>
<span class="fc" id="L285">        Optional&lt;TxContentUtxoOutputs&gt; optionalTxContentUtxoOutput = transactionUtxosResult.getValue().getOutputs().stream().filter(utxo -&gt; utxo.getAmount().stream().anyMatch(amount -&gt; amount.getUnit().equals(unit))).findFirst();</span>

<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (optionalTxContentUtxoOutput.isEmpty()) {</span>
<span class="nc" id="L288">            throw new IllegalArgumentException(&quot;Bootstrap token or datum not found in transaction outputs&quot;);</span>
        }

<span class="fc" id="L291">        TxContentUtxoOutputs txContentUtxoOutput = optionalTxContentUtxoOutput.get();</span>
<span class="fc" id="L292">        Utxo utxo = txContentUtxoOutput.toUtxos(bootstrapDatumEntity.getTransactionId());</span>

<span class="fc" id="L294">        StateDatum stateDatum = StateDatum.fromBootstrapDatum(utxo.getInlineDatum(), userAccountCredential);</span>
<span class="fc" id="L295">        stateDatum.setUVerifyCertificates(uVerifyCertificates);</span>
<span class="fc" id="L296">        stateDatum.setCountdown(stateDatum.getCountdown() - 1);</span>

<span class="fc" id="L298">        PlutusScript mintStateTokenScript = PlutusBlueprintUtil.getPlutusScriptFromCompiledCode(getMintStateTokenCode(network), PlutusVersion.v3);</span>
<span class="fc" id="L299">        Asset userStateToken = Asset.builder()</span>
<span class="fc" id="L300">                .name(&quot;0x&quot; + Hex.encodeHexString(userAccountCredential))</span>
<span class="fc" id="L301">                .value(BigInteger.ONE)</span>
<span class="fc" id="L302">                .build();</span>

<span class="fc" id="L304">        PlutusScript updateTestStateTokenScript = PlutusBlueprintUtil.getPlutusScriptFromCompiledCode(getUpdateStateTokenCode(network), PlutusVersion.v3);</span>
<span class="fc" id="L305">        String updateTestStateScriptAddress = AddressProvider.getEntAddress(updateTestStateTokenScript, fromCardanoNetwork(network)).toBech32();</span>

<span class="fc" id="L307">        UtxoSupplier utxoSupplier = new DefaultUtxoSupplier(backendService.getUtxoService());</span>
<span class="fc" id="L308">        List&lt;Utxo&gt; userUtxos = utxoSupplier.getAll(address);</span>

<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (userUtxos.isEmpty()) {</span>
<span class="nc" id="L311">            throw new IllegalArgumentException(&quot;No UTXOs found for user address&quot;);</span>
        }

<span class="fc" id="L314">        Utxo userUtxo = userUtxos.get(0);</span>
<span class="fc" id="L315">        String index = HexUtil.encodeHexString(ByteBuffer.allocate(2)</span>
<span class="fc" id="L316">                .order(ByteOrder.LITTLE_ENDIAN)</span>
<span class="fc" id="L317">                .putShort((short) userUtxo.getOutputIndex())</span>
<span class="fc" id="L318">                .array());</span>

<span class="fc" id="L320">        stateDatum.setId(DigestUtils.sha256Hex(HexUtil.decodeHexString(userUtxo.getTxHash() + index)));</span>

<span class="fc" id="L322">        ScriptTx scriptTransaction = new ScriptTx()</span>
<span class="fc" id="L323">                .readFrom(utxo)</span>
<span class="fc" id="L324">                .collectFrom(userUtxo)</span>
<span class="fc" id="L325">                .mintAsset(mintStateTokenScript, List.of(userStateToken), PlutusData.unit(), updateTestStateScriptAddress, stateDatum.toPlutusData(network));</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">        if (bootstrapDatumEntity.getFee() &gt; 0) {</span>
<span class="fc" id="L328">            long fee = bootstrapDatumEntity.getFee() / stateDatum.getFeeReceivers().size();</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            for (byte[] paymentCredential : stateDatum.getFeeReceivers()) {</span>
<span class="fc" id="L330">                Credential credential = Credential.fromKey(paymentCredential);</span>
<span class="fc" id="L331">                Address feeReceiverAddress = AddressProvider.getEntAddress(credential, fromCardanoNetwork(network));</span>
<span class="fc" id="L332">                scriptTransaction.payToAddress(feeReceiverAddress.getAddress(), Amount.lovelace(BigInteger.valueOf(fee)));</span>
<span class="fc" id="L333">            }</span>
        }

<span class="fc" id="L336">        QuickTxBuilder quickTxBuilder = new QuickTxBuilder(backendService);</span>

<span class="fc" id="L338">        long currentSlot = CardanoUtils.getLatestSlot(backendService);</span>
<span class="fc" id="L339">        long validFrom = currentSlot - 10;</span>
<span class="fc" id="L340">        long transactionTtl = currentSlot + 600; // 10 minutes</span>

<span class="fc" id="L342">        return quickTxBuilder.compose(scriptTransaction)</span>
<span class="fc" id="L343">                .validFrom(validFrom)</span>
<span class="fc" id="L344">                .validTo(transactionTtl)</span>
<span class="fc" id="L345">                .collateralPayer(address)</span>
<span class="fc" id="L346">                .feePayer(address)</span>
<span class="fc" id="L347">                .withRequiredSigners(userAddress)</span>
<span class="fc" id="L348">                .build();</span>
    }

    public Transaction invalidateBootstrapDatum(String bootstrapTokenName) throws ApiException {
<span class="fc" id="L352">        Optional&lt;BootstrapDatumEntity&gt; optionalBootstrapDatumEntity = bootstrapDatumService.getBootstrapDatum(bootstrapTokenName);</span>

<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (optionalBootstrapDatumEntity.isEmpty()) {</span>
<span class="nc" id="L355">            throw new IllegalArgumentException(&quot;Bootstrap datum with name &quot; + bootstrapTokenName + &quot; doesn't exists&quot;);</span>
        }

<span class="fc" id="L358">        BootstrapDatumEntity bootstrapDatum = optionalBootstrapDatumEntity.get();</span>
<span class="fc" id="L359">        Result&lt;TxContentUtxo&gt; transactionUtxosResult = backendService.getTransactionService().getTransactionUtxos(bootstrapDatum.getTransactionId());</span>

<span class="fc" id="L361">        String unit = getMintOrBurnAuthTokenHash(network) + HexUtil.encodeHexString(bootstrapTokenName.getBytes());</span>
<span class="fc" id="L362">        Optional&lt;TxContentUtxoOutputs&gt; optionalTxContentUtxoOutput = transactionUtxosResult.getValue().getOutputs().stream().filter(utxo -&gt; utxo.getAmount().stream().anyMatch(amount -&gt; amount.getUnit().equals(unit))).findFirst();</span>

<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (optionalTxContentUtxoOutput.isEmpty()) {</span>
<span class="nc" id="L365">            throw new IllegalArgumentException(&quot;Bootstrap token or datum not found in transaction outputs&quot;);</span>
        }

<span class="fc" id="L368">        TxContentUtxoOutputs txContentUtxoOutput = optionalTxContentUtxoOutput.get();</span>
<span class="fc" id="L369">        Utxo utxo = txContentUtxoOutput.toUtxos(bootstrapDatum.getTransactionId());</span>

<span class="fc" id="L371">        PlutusScript authorizationScript = PlutusBlueprintUtil.getPlutusScriptFromCompiledCode(getMintOrBurnAuthTokenCode(network), PlutusVersion.v3);</span>
<span class="fc" id="L372">        QuickTxBuilder quickTxBuilder = new QuickTxBuilder(backendService);</span>

<span class="fc" id="L374">        Asset authorizationToken = Asset.builder()</span>
<span class="fc" id="L375">                .name(bootstrapDatum.getTokenName())</span>
<span class="fc" id="L376">                .value(BigInteger.valueOf(-1))</span>
<span class="fc" id="L377">                .build();</span>


<span class="fc" id="L380">        UtxoSupplier utxoSupplier = new DefaultUtxoSupplier(backendService.getUtxoService());</span>
<span class="fc" id="L381">        List&lt;Utxo&gt; userUtxos = utxoSupplier.getAll(serviceUserAddress.getAddress());</span>

<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (userUtxos.isEmpty()) {</span>
<span class="nc" id="L384">            throw new IllegalArgumentException(&quot;No UTXOs found for user address&quot;);</span>
        }

<span class="fc" id="L387">        Utxo userUtxo = userUtxos.get(0);</span>

<span class="fc" id="L389">        ScriptTx scriptTx = new ScriptTx()</span>
<span class="fc" id="L390">                .attachSpendingValidator(authorizationScript)</span>
<span class="fc" id="L391">                .collectFrom(utxo, PlutusData.unit())</span>
<span class="fc" id="L392">                .collectFrom(userUtxo)</span>
<span class="fc" id="L393">                .mintAsset(authorizationScript, List.of(authorizationToken), PlutusData.unit());</span>

<span class="fc" id="L395">        return quickTxBuilder.compose(scriptTx)</span>
<span class="fc" id="L396">                .feePayer(serviceUserAddress.getAddress())</span>
<span class="fc" id="L397">                .withRequiredSigners(serviceUserAddress)</span>
<span class="fc" id="L398">                .build();</span>
    }

    public Transaction initializeBootstrapDatum(BootstrapDatum bootstrapDatum) throws ApiException {
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (bootstrapDatumService.bootstrapDatumAlreadyExists(bootstrapDatum.getTokenName())) {</span>
<span class="nc" id="L403">            throw new IllegalArgumentException(&quot;Bootstrap datum with name &quot; + bootstrapDatum.getTokenName() + &quot; already exists&quot;);</span>
        }

<span class="fc" id="L406">        PlutusScript authorizationScript = PlutusBlueprintUtil.getPlutusScriptFromCompiledCode(getMintOrBurnAuthTokenCode(network), PlutusVersion.v3);</span>
<span class="fc" id="L407">        QuickTxBuilder quickTxBuilder = new QuickTxBuilder(backendService);</span>

<span class="fc" id="L409">        Asset authorizationToken = Asset.builder()</span>
<span class="fc" id="L410">                .name(bootstrapDatum.getTokenName())</span>
<span class="fc" id="L411">                .value(BigInteger.ONE)</span>
<span class="fc" id="L412">                .build();</span>

<span class="fc" id="L414">        String scriptAddress = AddressProvider.getEntAddress(authorizationScript, fromCardanoNetwork(network)).toBech32();</span>
<span class="fc" id="L415">        ScriptTx scriptTx = new ScriptTx()</span>
<span class="fc" id="L416">                .mintAsset(authorizationScript, List.of(authorizationToken), PlutusData.unit(), scriptAddress, bootstrapDatum.toPlutusData(network));</span>

<span class="fc" id="L418">        return quickTxBuilder.compose(scriptTx)</span>
<span class="fc" id="L419">                .feePayer(serviceUserAddress.getAddress())</span>
<span class="fc" id="L420">                .withRequiredSigners(serviceUserAddress)</span>
<span class="fc" id="L421">                .build();</span>
    }

    public Transaction invalidateState(Address userAddress, String transactionId) throws ApiException {
<span class="nc" id="L425">        Optional&lt;byte[]&gt; optionalUserPaymentCredential = userAddress.getPaymentCredentialHash();</span>

<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (optionalUserPaymentCredential.isEmpty()) {</span>
<span class="nc" id="L428">            throw new IllegalArgumentException(&quot;Invalid Cardano payment address&quot;);</span>
        }

<span class="nc" id="L431">        byte[] userAccountCredential = optionalUserPaymentCredential.get();</span>
<span class="nc" id="L432">        String unit = getMintStateTokenHash(network) + Hex.encodeHexString(userAccountCredential);</span>

<span class="nc" id="L434">        Optional&lt;Utxo&gt; optionalUtxo = ValidatorUtils.getUtxoByTransactionAndUnit(transactionId, unit, backendService);</span>

<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (optionalUtxo.isEmpty()) {</span>
<span class="nc" id="L437">            throw new IllegalArgumentException(&quot;State token not found in transaction outputs&quot;);</span>
        }

<span class="nc" id="L440">        Utxo utxo = optionalUtxo.get();</span>
<span class="nc" id="L441">        PlutusScript updateTestStateTokenScript = PlutusBlueprintUtil.getPlutusScriptFromCompiledCode(getUpdateStateTokenCode(network), PlutusVersion.v3);</span>
<span class="nc" id="L442">        PlutusScript mintStateTokenScript = PlutusBlueprintUtil.getPlutusScriptFromCompiledCode(getMintStateTokenCode(network), PlutusVersion.v3);</span>

<span class="nc" id="L444">        Asset userStateToken = Asset.builder()</span>
<span class="nc" id="L445">                .name(&quot;0x&quot; + Hex.encodeHexString(userAccountCredential))</span>
<span class="nc" id="L446">                .value(BigInteger.valueOf(-1))</span>
<span class="nc" id="L447">                .build();</span>

<span class="nc" id="L449">        ScriptTx updateStateTokenTx = new ScriptTx()</span>
<span class="nc" id="L450">                .collectFrom(utxo, PlutusData.unit())</span>
<span class="nc" id="L451">                .attachSpendingValidator(updateTestStateTokenScript)</span>
<span class="nc" id="L452">                .mintAsset(mintStateTokenScript, List.of(userStateToken), PlutusData.unit());</span>

<span class="nc" id="L454">        long currentSlot = CardanoUtils.getLatestSlot(backendService);</span>
<span class="nc" id="L455">        long validFrom = currentSlot - 10;</span>
<span class="nc" id="L456">        long transactionTtl = currentSlot + 600; // 10 minutes</span>

<span class="nc" id="L458">        QuickTxBuilder quickTxBuilder = new QuickTxBuilder(backendService);</span>
<span class="nc" id="L459">        return quickTxBuilder.compose(updateStateTokenTx)</span>
<span class="nc" id="L460">                .validFrom(validFrom)</span>
<span class="nc" id="L461">                .validTo(transactionTtl)</span>
<span class="nc" id="L462">                .feePayer(userAddress.getAddress())</span>
<span class="nc" id="L463">                .withRequiredSigners(userAddress)</span>
<span class="nc" id="L464">                .build();</span>
    }

    public void processAddressUtxos(List&lt;AddressUtxo&gt; addressUtxos) {
<span class="fc bfc" id="L468" title="All 2 branches covered.">        for (AddressUtxo addressUtxo : addressUtxos) {</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            if (includesBootstrapToken(addressUtxo, network)) {</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">                if (isMintingTransaction(addressUtxo, ValidatorUtils.getMintOrBurnAuthTokenHash(network))) {</span>
<span class="fc" id="L471">                    BootstrapDatumEntity bootstrapDatumEntity = BootstrapDatumEntity.fromAddressUtxo(addressUtxo, network);</span>
<span class="fc" id="L472">                    bootstrapDatumService.save(bootstrapDatumEntity);</span>
<span class="pc bnc" id="L473" title="All 2 branches missed.">                } else if (isBurningTransaction(addressUtxo, ValidatorUtils.getMintOrBurnAuthTokenHash(network))) {</span>
<span class="nc" id="L474">                    bootstrapDatumService.markAsInvalid(getBootstrapTokenName(addressUtxo, network), addressUtxo.getSlot());</span>
                } else {
<span class="nc" id="L476">                    throw new IllegalArgumentException(&quot;Invalid bootstrap token transaction amount!&quot;);</span>
                }
<span class="fc bfc" id="L478" title="All 2 branches covered.">            } else if (includesStateToken(addressUtxo, network)) {</span>
<span class="fc" id="L479">                StateDatum stateDatum = StateDatum.fromUtxoDatum(addressUtxo.getInlineDatum());</span>
<span class="fc" id="L480">                Optional&lt;StateDatumEntity&gt; optionalStateDatumEntity = stateDatumService.findByAddressUtxo(addressUtxo);</span>

<span class="pc bpc" id="L482" title="1 of 2 branches missed.">                if (isBurningTransaction(addressUtxo, ValidatorUtils.getMintStateTokenHash(network))) {</span>
<span class="nc" id="L483">                    stateDatumService.invalidateStateDatum(stateDatum.getId(), addressUtxo.getSlot());</span>
                } else {
                    final StateDatumEntity stateDatumEntity;
<span class="fc bfc" id="L486" title="All 2 branches covered.">                    if (optionalStateDatumEntity.isEmpty()) {</span>
<span class="fc" id="L487">                        BootstrapDatumEntity bootstrapDatumEntity = bootstrapDatumService.getBootstrapDatum(stateDatum.getBootstrapDatumName())</span>
<span class="pc" id="L488">                                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Bootstrap datum not found&quot;));</span>
<span class="fc" id="L489">                        stateDatumEntity = StateDatumEntity.fromAddressUtxo(addressUtxo, bootstrapDatumEntity);</span>
<span class="fc" id="L490">                        stateDatumService.save(stateDatumEntity);</span>
<span class="fc" id="L491">                    } else {</span>
<span class="fc" id="L492">                        stateDatumEntity = optionalStateDatumEntity.get();</span>
<span class="fc" id="L493">                        stateDatumEntity.setTransactionId(addressUtxo.getTxHash());</span>
<span class="fc" id="L494">                        stateDatumEntity.setCountdown(stateDatum.getCountdown());</span>
<span class="fc" id="L495">                        stateDatumService.updateStateDatum(stateDatumEntity, addressUtxo.getSlot());</span>
                    }

<span class="fc" id="L498">                    List&lt;UVerifyCertificate&gt; uVerifyCertificates = stateDatum.getUVerifyCertificates();</span>
<span class="fc" id="L499">                    List&lt;UVerifyCertificateEntity&gt; uVerifyCertificatesEntities = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">                    for (UVerifyCertificate uVerifyCertificate : uVerifyCertificates) {</span>
<span class="fc" id="L501">                        UVerifyCertificateEntity uVerifyCertificateEntity = UVerifyCertificateEntity.fromUVerifyCertificate(uVerifyCertificate);</span>
<span class="fc" id="L502">                        uVerifyCertificateEntity.setSlot(addressUtxo.getSlot());</span>
<span class="fc" id="L503">                        uVerifyCertificateEntity.setStateDatum(stateDatumEntity);</span>
<span class="fc" id="L504">                        uVerifyCertificateEntity.setTransactionId(addressUtxo.getTxHash());</span>
<span class="fc" id="L505">                        uVerifyCertificateEntity.setOutputIndex(addressUtxo.getOutputIndex());</span>
<span class="fc" id="L506">                        uVerifyCertificateEntity.setBlockHash(addressUtxo.getBlockHash());</span>
<span class="fc" id="L507">                        uVerifyCertificateEntity.setBlockNumber(addressUtxo.getBlockNumber());</span>
<span class="fc" id="L508">                        uVerifyCertificateEntity.setCreationTime(new Date(addressUtxo.getBlockTime() * 1000));</span>
<span class="fc" id="L509">                        uVerifyCertificatesEntities.add(uVerifyCertificateEntity);</span>
<span class="fc" id="L510">                    }</span>
<span class="fc" id="L511">                    uVerifyCertificateService.saveAllCertificates(uVerifyCertificatesEntities);</span>
                }
            }
<span class="fc" id="L514">        }</span>
<span class="fc" id="L515">    }</span>

    public void handleRollbackToSlot(long slot) {
<span class="fc" id="L518">        bootstrapDatumService.undoInvalidationBeforeSlot(slot);</span>
<span class="fc" id="L519">        uVerifyCertificateService.deleteAllCertificatesAfterSlot(slot);</span>
<span class="fc" id="L520">        stateDatumService.undoInvalidationBeforeSlot(slot);</span>
<span class="fc" id="L521">        stateDatumService.handleRollbackToSlot(slot);</span>
<span class="fc" id="L522">        bootstrapDatumService.deleteAllAfterSlot(slot);</span>
<span class="fc" id="L523">    }</span>

    public Transaction invalidateStates(Address userAddress, List&lt;String&gt; transactionIds) throws ApiException {
<span class="nc" id="L526">        Optional&lt;byte[]&gt; optionalUserPaymentCredential = userAddress.getPaymentCredentialHash();</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (optionalUserPaymentCredential.isEmpty()) {</span>
<span class="nc" id="L529">            throw new IllegalArgumentException(&quot;Invalid Cardano payment address&quot;);</span>
        }

<span class="nc" id="L532">        byte[] userAccountCredential = optionalUserPaymentCredential.get();</span>
<span class="nc" id="L533">        String unit = getMintStateTokenHash(network) + Hex.encodeHexString(userAccountCredential);</span>

<span class="nc" id="L535">        PlutusScript updateTestStateTokenScript = PlutusBlueprintUtil.getPlutusScriptFromCompiledCode(getUpdateStateTokenCode(network), PlutusVersion.v3);</span>
<span class="nc" id="L536">        PlutusScript mintStateTokenScript = PlutusBlueprintUtil.getPlutusScriptFromCompiledCode(getMintStateTokenCode(network), PlutusVersion.v3);</span>
<span class="nc" id="L537">        Asset userStateToken = Asset.builder()</span>
<span class="nc" id="L538">                .name(&quot;0x&quot; + Hex.encodeHexString(userAccountCredential))</span>
<span class="nc" id="L539">                .value(BigInteger.valueOf(-1))</span>
<span class="nc" id="L540">                .build();</span>

<span class="nc" id="L542">        List&lt;ScriptTx&gt; invalidateStateTransactions = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        for (String transactionId : transactionIds) {</span>
<span class="nc" id="L544">            Optional&lt;Utxo&gt; optionalUtxo = ValidatorUtils.getUtxoByTransactionAndUnit(transactionId, unit, backendService);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (optionalUtxo.isEmpty()) {</span>
<span class="nc" id="L546">                throw new IllegalArgumentException(&quot;State token not found in transaction outputs&quot;);</span>
            }
<span class="nc" id="L548">            Utxo utxo = optionalUtxo.get();</span>

<span class="nc" id="L550">            invalidateStateTransactions.add(new ScriptTx()</span>
<span class="nc" id="L551">                    .collectFrom(utxo, PlutusData.unit())</span>
<span class="nc" id="L552">                    .attachSpendingValidator(updateTestStateTokenScript)</span>
<span class="nc" id="L553">                    .mintAsset(mintStateTokenScript, List.of(userStateToken), PlutusData.unit()));</span>
<span class="nc" id="L554">        }</span>

<span class="nc" id="L556">        long currentSlot = CardanoUtils.getLatestSlot(backendService);</span>
<span class="nc" id="L557">        long validFrom = currentSlot - 10;</span>
<span class="nc" id="L558">        long transactionTtl = currentSlot + 600; // 10 minutes</span>

<span class="nc" id="L560">        QuickTxBuilder quickTxBuilder = new QuickTxBuilder(backendService);</span>
<span class="nc" id="L561">        return quickTxBuilder.compose(invalidateStateTransactions.toArray(new ScriptTx[0]))</span>
<span class="nc" id="L562">                .validFrom(validFrom)</span>
<span class="nc" id="L563">                .validTo(transactionTtl)</span>
<span class="nc" id="L564">                .feePayer(userAddress.getAddress())</span>
<span class="nc" id="L565">                .withRequiredSigners(userAddress)</span>
<span class="nc" id="L566">                .build();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>