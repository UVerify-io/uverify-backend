<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserStateService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Uverify Backend</a> &gt; <a href="index.source.html" class="el_package">io.uverify.backend.service</a> &gt; <span class="el_source">UserStateService.java</span></div><h1>UserStateService.java</h1><pre class="source lang-java linenums">/*
 * UVerify Backend
 * Copyright (C) 2025 Fabian Bormann
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package io.uverify.backend.service;

import com.bloxbean.cardano.client.account.Account;
import com.bloxbean.cardano.client.address.Address;
import com.bloxbean.cardano.client.api.exception.ApiException;
import com.bloxbean.cardano.client.crypto.api.impl.EdDSASigningProvider;
import com.bloxbean.cardano.client.exception.CborSerializationException;
import com.bloxbean.cardano.client.transaction.spec.Transaction;
import com.bloxbean.cardano.client.util.HexUtil;
import io.uverify.backend.dto.*;
import io.uverify.backend.entity.BootstrapDatumEntity;
import io.uverify.backend.entity.StateDatumEntity;
import io.uverify.backend.enums.CardanoNetwork;
import io.uverify.backend.enums.UserAction;
import io.uverify.backend.repository.BootstrapDatumRepository;
import io.uverify.backend.repository.StateDatumRepository;
import io.uverify.backend.util.CardanoUtils;
import lombok.extern.slf4j.Slf4j;
import org.cardanofoundation.cip30.AddressFormat;
import org.cardanofoundation.cip30.CIP30Verifier;
import org.cardanofoundation.cip30.Cip30VerificationResult;
import org.cardanofoundation.cip30.MessageFormat;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Optional;

import static io.uverify.backend.util.CardanoUtils.fromCardanoNetwork;

<span class="fc" id="L52">@Slf4j</span>
@Service
public class UserStateService {

    private final Account facilitator;
    private final CardanoNetwork network;

    @Autowired
    StateDatumRepository stateDatumRepository;

    @Autowired
    BootstrapDatumRepository bootstrapDatumRepository;

    @Autowired
    CardanoBlockchainService cardanoBlockchainService;

    @Autowired
    public UserStateService(@Value(&quot;${cardano.facilitator.user.mnemonic:}&quot;) String facilitatorAccountMnemonic,
<span class="fc" id="L70">                            @Value(&quot;${cardano.network}&quot;) String network) {</span>
<span class="fc" id="L71">        this.network = CardanoNetwork.valueOf(network);</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (facilitatorAccountMnemonic.isEmpty()) {</span>
<span class="nc" id="L73">            log.warn(&quot;Facilitator account mnemonic is empty. Generating a temporary account. &quot; +</span>
                    &quot;This is not recommended for production use and may result in an odd user experience, &quot; +
                    &quot;if this UVerify backend service restarts while requests are still pending.&quot;);
<span class="nc" id="L76">            this.facilitator = new Account(fromCardanoNetwork(this.network));</span>
        } else {
<span class="fc" id="L78">            this.facilitator = Account.createFromMnemonic(fromCardanoNetwork(this.network), facilitatorAccountMnemonic);</span>
        }
<span class="fc" id="L80">    }</span>

    private UserActionResponse buildUserActionResponse(String address, UserAction action) {
<span class="fc" id="L83">        return buildUserActionResponse(address, action, null);</span>
    }

    private UserActionResponse buildUserActionResponse(String address, UserAction action, String stateId) {
<span class="fc" id="L87">        long timestamp = System.currentTimeMillis();</span>
<span class="fc" id="L88">        String actionName = action.name();</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (stateId != null) {</span>
<span class="nc" id="L90">            actionName += &quot;:&quot; + stateId;</span>
        }

<span class="fc" id="L93">        String message = &quot;[&quot; + actionName + &quot;@&quot; + timestamp + &quot;] Please sign this message with your private key to verify, &quot; +</span>
                &quot;that you are the owner of the address &quot; + address + &quot;.&quot;;
<span class="fc" id="L95">        EdDSASigningProvider edDSASigningProvider = new EdDSASigningProvider();</span>
<span class="fc" id="L96">        String signature = HexUtil.encodeHexString(</span>
<span class="fc" id="L97">                edDSASigningProvider.signExtended(message.getBytes(StandardCharsets.UTF_8), facilitator.privateKeyBytes()));</span>
<span class="fc" id="L98">        return UserActionResponse.builder()</span>
<span class="fc" id="L99">                .address(address)</span>
<span class="fc" id="L100">                .action(action)</span>
<span class="fc" id="L101">                .signature(signature)</span>
<span class="fc" id="L102">                .timestamp(timestamp)</span>
<span class="fc" id="L103">                .message(message)</span>
<span class="fc" id="L104">                .status(HttpStatus.OK)</span>
<span class="fc" id="L105">                .build();</span>
    }


    public UserActionResponse requestUserInfo(String address) {
<span class="fc" id="L110">        return buildUserActionResponse(address, UserAction.USER_INFO);</span>
    }

    public UserActionResponse requestInvalidateState(String address, String stateId) {
<span class="nc" id="L114">        return buildUserActionResponse(address, UserAction.INVALIDATE_STATE, stateId);</span>
    }

    public UserActionResponse requestOptOut(String address) {
<span class="nc" id="L118">        return buildUserActionResponse(address, UserAction.OPT_OUT);</span>
    }

    private boolean signaturesAreValid(ExecuteUserActionRequest actionRequest) {
<span class="fc" id="L122">        EdDSASigningProvider edDSASigningProvider = new EdDSASigningProvider();</span>

<span class="fc" id="L124">        String actionName = actionRequest.getAction().name();</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (actionRequest.getStateId() != null) {</span>
<span class="nc" id="L126">            actionName += &quot;:&quot; + actionRequest.getStateId();</span>
        }

<span class="fc" id="L129">        String message = &quot;[&quot; + actionName + &quot;@&quot; + actionRequest.getTimestamp() + &quot;] Please sign this message with your private key to verify, &quot; +</span>
<span class="fc" id="L130">                &quot;that you are the owner of the address &quot; + actionRequest.getAddress() + &quot;.&quot;;</span>

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (!message.equals(actionRequest.getMessage())) {</span>
<span class="nc" id="L133">            return false;</span>
        }

<span class="fc" id="L136">        CIP30Verifier cip30Verifier = new CIP30Verifier(actionRequest.getUserSignature(), actionRequest.getUserPublicKey());</span>
<span class="fc" id="L137">        Cip30VerificationResult cip30VerificationResult = cip30Verifier.verify();</span>
<span class="fc" id="L138">        Optional&lt;String&gt; optionalUserAddress = cip30VerificationResult.getAddress(AddressFormat.TEXT);</span>

<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (optionalUserAddress.isEmpty()) {</span>
<span class="nc" id="L141">            return false;</span>
        }

<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        return edDSASigningProvider.verify(HexUtil.decodeHexString(actionRequest.getSignature()),</span>
<span class="fc" id="L145">                actionRequest.getMessage().getBytes(), facilitator.publicKeyBytes()) &amp;&amp;</span>
<span class="pc bpc" id="L146" title="2 of 4 branches missed.">                cip30VerificationResult.isValid() &amp;&amp; message.equals(cip30VerificationResult.getMessage(MessageFormat.TEXT))</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">                &amp;&amp; actionRequest.getAddress().equals(optionalUserAddress.get());</span>
    }

    public ExecuteUserActionResponse executeUserOptOut(ExecuteUserActionRequest request) {
<span class="nc bnc" id="L151" title="All 4 branches missed.">        if (signaturesAreValid(request) &amp;&amp; hasValidTimeframe(request.getTimestamp())) {</span>
<span class="nc" id="L152">            String userCredential = HexUtil.encodeHexString(CardanoUtils.extractCredentialFromAddress(request.getAddress()));</span>
<span class="nc" id="L153">            List&lt;StateDatumEntity&gt; stateDatumEntities = stateDatumRepository.findByOwner(userCredential);</span>
<span class="nc" id="L154">            Address userAddress = new Address(request.getAddress());</span>
<span class="nc" id="L155">            ExecuteUserActionResponse response = ExecuteUserActionResponse.builder().status(HttpStatus.OK).build();</span>
            try {
<span class="nc" id="L157">                Transaction unsignedTransaction = cardanoBlockchainService.invalidateStates(userAddress, stateDatumEntities.stream().map(StateDatumEntity::getTransactionId).toList());</span>
<span class="nc" id="L158">                response.setUnsignedTransaction(unsignedTransaction.serializeToHex());</span>
<span class="nc" id="L159">            } catch (ApiException | CborSerializationException exception) {</span>
<span class="nc" id="L160">                log.error(&quot;Failed to invalidate states&quot;, exception);</span>
<span class="nc" id="L161">                response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L162">                response.setError(&quot;Failed to invalidate states.&quot;);</span>
<span class="nc" id="L163">            }</span>
<span class="nc" id="L164">            return response;</span>
        } else {
<span class="nc" id="L166">            return ExecuteUserActionResponse.builder().status(HttpStatus.BAD_REQUEST)</span>
<span class="nc" id="L167">                    .error(&quot;The provided signatures are not valid or the request is outdated (signature older than 10 minutes).&quot;).build();</span>
        }
    }

    public ExecuteUserActionResponse executeStateInvalidationRequest(ExecuteUserActionRequest actionRequest) {
<span class="nc bnc" id="L172" title="All 4 branches missed.">        if (signaturesAreValid(actionRequest) &amp;&amp; hasValidTimeframe(actionRequest.getTimestamp())) {</span>
<span class="nc" id="L173">            Optional&lt;StateDatumEntity&gt; optionalStateDatum = stateDatumRepository.findById(actionRequest.getStateId());</span>

<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (optionalStateDatum.isEmpty()) {</span>
<span class="nc" id="L176">                return ExecuteUserActionResponse.builder()</span>
<span class="nc" id="L177">                        .status(HttpStatus.BAD_REQUEST)</span>
<span class="nc" id="L178">                        .error(&quot;State with the provided ID does not exist.&quot;)</span>
<span class="nc" id="L179">                        .build();</span>
            }

<span class="nc" id="L182">            StateDatumEntity stateDatumEntity = optionalStateDatum.get();</span>
<span class="nc" id="L183">            Address userAddress = new Address(stateDatumEntity.getOwner());</span>
<span class="nc" id="L184">            ExecuteUserActionResponse response = ExecuteUserActionResponse.builder().status(HttpStatus.OK).build();</span>
            try {
<span class="nc" id="L186">                response.setUnsignedTransaction(cardanoBlockchainService.invalidateState(userAddress, stateDatumEntity.getTransactionId()).serializeToHex());</span>
<span class="nc" id="L187">            } catch (ApiException exception) {</span>
<span class="nc" id="L188">                log.error(&quot;Failed to invalidate state&quot;, exception);</span>
<span class="nc" id="L189">                response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L190">                response.setError(&quot;Failed to invalidate state.&quot;);</span>
<span class="nc" id="L191">            } catch (CborSerializationException exception) {</span>
<span class="nc" id="L192">                log.error(&quot;Failed to serialize transaction&quot;, exception);</span>
<span class="nc" id="L193">                response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L194">                response.setError(&quot;Failed to serialize transaction.&quot;);</span>
<span class="nc" id="L195">            }</span>
<span class="nc" id="L196">            return response;</span>
        }
<span class="nc" id="L198">        return ExecuteUserActionResponse.builder().status(HttpStatus.BAD_REQUEST)</span>
<span class="nc" id="L199">                .error(&quot;The provided signatures are not valid or the request is outdated (signature older than 10 minutes).&quot;).build();</span>
    }

    public ExecuteUserActionResponse executeUserInfoRequest(ExecuteUserActionRequest actionRequest) {
<span class="pc bpc" id="L203" title="2 of 4 branches missed.">        if (signaturesAreValid(actionRequest) &amp;&amp; hasValidTimeframe(actionRequest.getTimestamp())) {</span>
<span class="fc" id="L204">            String userCredential = HexUtil.encodeHexString(CardanoUtils.extractCredentialFromAddress(actionRequest.getAddress()));</span>
<span class="fc" id="L205">            List&lt;BootstrapDatumEntity&gt; bootstrapDatumEntities = bootstrapDatumRepository.findAllWhitelisted();</span>
<span class="fc" id="L206">            List&lt;BootstrapDatumEntity&gt; customBootstrapDatumEntities = bootstrapDatumRepository.findByAllowedCredential(userCredential, 2);</span>

<span class="fc" id="L208">            bootstrapDatumEntities.addAll(customBootstrapDatumEntities);</span>

<span class="fc" id="L210">            List&lt;StateDatumEntity&gt; stateDatumEntities = stateDatumRepository.findByOwner(userCredential);</span>

<span class="fc" id="L212">            return ExecuteUserActionResponse.builder()</span>
<span class="fc" id="L213">                    .state(UserState.builder()</span>
<span class="fc" id="L214">                            .bootstrapDatums(bootstrapDatumEntities.stream()</span>
<span class="fc" id="L215">                                    .map(bootstrapDatumEntity -&gt;</span>
<span class="fc" id="L216">                                            BootstrapData.fromBootstrapDatumEntity(bootstrapDatumEntity, network))</span>
<span class="fc" id="L217">                                    .toList())</span>
<span class="fc" id="L218">                            .states(stateDatumEntities.stream().map(stateDatumEntity -&gt;</span>
<span class="fc" id="L219">                                            StateData.fromStateDatumEntity(stateDatumEntity, network))</span>
<span class="fc" id="L220">                                    .toList())</span>
<span class="fc" id="L221">                            .build())</span>
<span class="fc" id="L222">                    .status(HttpStatus.OK)</span>
<span class="fc" id="L223">                    .build();</span>
        }
<span class="nc" id="L225">        return ExecuteUserActionResponse.builder().status(HttpStatus.BAD_REQUEST)</span>
<span class="nc" id="L226">                .error(&quot;The provided signatures are not valid or the request is outdated (signature older than 10 minutes).&quot;).build();</span>
    }

    private boolean hasValidTimeframe(long timestamp) {
<span class="fc" id="L230">        long currentTime = System.currentTimeMillis();</span>
<span class="fc" id="L231">        long timeDifference = Math.abs(currentTime - timestamp);</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        return timeDifference &lt;= 600000;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>